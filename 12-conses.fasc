(#Y(si::bytecodes nil nil (1 0 16 1 29) #1=#A(t (249) ("LPD3-UTILS" si::select-package lpd3-utils::find2 ext::location (defun lpd3-utils::find2) (#2=#P"/data/data/org.eql5.android.repl/files/quicklisp/local-projects/lpd3-utils/12-conses.lisp" . 76) ext::annotate :lambda-list (lpd3-utils::fn lpd3-utils::lst) lpd3-utils::fn lpd3-utils::lst lpd3-utils::value #Y(lpd3-utils::find2 nil nil (24 45 9 24 45 10 26 10 0 76 39 5 75 73 38 37 13 1 10 0 4 12 20 1 23 45 11 10 0 39 11 10 1 4 12 13 0 72 2 38 10 13 2 10 1 5 12 19 2 2 43 1 29) #1# #2# 76) si::fset function "Given a function and a list, return
  two values: the first item in lst that 
  returns non-nil under fn, and the
  non-nil value. Otherwise, return nil." si::set-documentation lpd3-utils::before (defun lpd3-utils::before) (#2# . 420) (lpd3-utils::x lpd3-utils::y lpd3-utils::lst &key (lpd3-utils::test (function eql))) lpd3-utils::x lpd3-utils::y (nil :test) eql lpd3-utils::test first #Y(lpd3-utils::before nil nil (24 45 21 24 45 22 24 45 10 28 23 22 40 4 33 24 12 46 25 10 1 73 39 52 10 1 4 45 26 13 1 13 3 13 0 20 2 23 39 5 75 73 38 30 13 1 13 4 13 0 20 2 23 39 6 10 2 73 38 14 13 4 13 3 10 2 5 12 13 1 19 4 17 43 1 29) #1# #2# 420) "Given two items x and y and a list, 
  is x present and found earlier in the
  list than y (which need not be present)?
  If so, returns the tail beginning with
  x.
  Takes a :test kwarg, defaulting to eql." lpd3-utils::after (defun lpd3-utils::after) (#2# . 850) (lpd3-utils::x lpd3-utils::y lpd3-utils::lst &key (lpd3-utils::test (function eql))) (nil :test) rest :test member #Y(lpd3-utils::after nil nil (24 45 21 24 45 22 24 45 10 28 33 22 40 4 33 24 12 46 25 13 2 13 3 13 1 13 0 19 4 17 45 34 10 0 73 39 12 13 4 13 0 14 35 13 1 19 4 36 43 1 29) #1# #2# 850) "Given two items x and y and a list, 
  are both items present in the list 
  and does x appear after y? If so, 
  returns the tail of the list beginning
  with x. Takes 
  a :test kwarg, defaulting to eql." lpd3-utils::duplicatep (defun lpd3-utils::duplicatep) (#2# . 1184) (lpd3-utils::obj lpd3-utils::lst &key (lpd3-utils::test (function eql))) lpd3-utils::obj (nil :test) #Y(lpd3-utils::duplicatep nil nil (24 45 43 24 45 10 28 44 22 40 4 33 24 12 46 25 13 2 13 2 13 1 14 35 13 0 19 4 36 5 12 14 35 13 0 19 4 36 29) #1# #2# 1184) "Takes an item and a list. If item appears
  more than once in the list, return the 
  tail of the list beginning with the 
  second occurrence of the object. 
  Takes a :test kwarg, defaulting to #'eql" lpd3-utils::split-if (defun lpd3-utils::split-if) (#2# . 1512) (lpd3-utils::fn lpd3-utils::lst) lpd3-utils::acc lpd3-utils::src nreverse #Y(lpd3-utils::split-if nil nil (24 45 9 24 45 10 26 75 45 51 10 1 45 52 38 16 10 0 4 12 10 1 3 51 1 10 0 5 12 53 0 10 0 76 40 10 13 3 10 0 4 12 20 1 23 39 -30 10 1 16 53 12 13 0 72 2 43 1 43 1 29) #1# #2# 1512) "Given a function and a list, returns
  two lists: the initial items that return
  nil under fn, and the rest of the input
  list beginning with the first item that
  returns non-nil under fn." lpd3-utils::most (defun lpd3-utils::most) (#2# . 1899) (lpd3-utils::fn lpd3-utils::lst) lpd3-utils::wins max si::%dolist-var lpd3-utils::score > #Y(lpd3-utils::most nil nil (24 45 9 24 45 10 26 10 0 76 39 7 77 77 72 2 38 76 10 0 4 45 60 13 2 13 0 20 1 23 45 61 10 2 5 45 62 38 41 10 0 4 45 43 13 5 13 0 20 1 23 45 63 13 0 13 3 19 2 64 39 9 10 1 51 4 10 0 51 3 43 1 10 1 5 51 1 43 1 10 0 40 -43 43 1 13 1 13 0 72 2 43 2 29) #1# #2# 1899) "Given a function that returns a real
  number and a list, returns two values: 
  the first item in list that returned the
  maximum value under function, and that
  value." lpd3-utils::mostn (defun lpd3-utils::mostn) (#2# . 2403) (lpd3-utils::fn lpd3-utils::lst) list lpd3-utils::result = #Y(lpd3-utils::mostn nil nil (24 45 9 24 45 10 26 11 71 76 39 7 77 77 72 2 38 101 10 0 4 6 1 12 13 1 10 0 4 12 20 1 23 12 46 61 46 72 10 2 5 45 62 38 57 10 0 4 45 43 13 5 13 0 20 1 23 45 63 13 0 13 4 19 2 64 39 9 10 1 6 1 51 3 38 17 13 0 13 4 19 2 73 39 8 13 1 10 3 3 51 3 43 1 10 1 5 51 1 43 1 10 0 40 -59 43 1 10 0 16 53 12 13 1 72 2 43 2 29) #1# #2# 2403) "Takes a function that returns a real
  number and a list. Returns two values:
  a list containing every item in the 
  input list that tied for producing the
  highest value under function and that 
  value." lpd3-utils::mapcars (defun lpd3-utils::mapcars) (#2# . 3026) (lpd3-utils::fn &rest lpd3-utils::lsts) lpd3-utils::lsts #Y(lpd3-utils::mapcars nil nil (24 45 9 27 45 80 75 45 72 10 1 45 62 38 50 10 0 4 45 10 10 0 45 62 38 26 10 0 4 45 43 13 6 13 0 20 1 23 12 10 4 3 51 4 10 1 5 51 1 43 1 10 0 40 -28 43 1 10 1 5 51 1 43 1 10 0 40 -52 43 1 10 0 16 53 43 1 29) #1# #2# 3026) "Takes a function of one arg and an arbitrary 
  number of lists. Returns a list which
  is the collected results of applying
  the function to each item in the first
  list, followed by the results from 
  the second list, etc., until the 
  last list is exhausted." lpd3-utils::mapa-b (defun lpd3-utils::mapa-b) (#2# . 3462) (lpd3-utils::fn lpd3-utils::a lpd3-utils::b) lpd3-utils::a lpd3-utils::b lpd3-utils::results lpd3-utils::i 1+ #Y(lpd3-utils::mapa-b nil nil (24 45 9 24 45 87 24 45 88 26 13 1 77 46 89 46 90 38 24 10 0 16 91 12 13 4 13 0 20 1 23 12 10 1 3 51 1 12 53 1 53 0 13 0 13 2 19 2 64 39 -31 10 1 16 53 43 2 29) #1# #2# 3462) "(mapa-b (fn a b). Returns a list
  containing the results of invoking fn 
  on a, then a+1, ... b." lpd3-utils::map0-n (defun lpd3-utils::map0-n) (#2# . 3698) (lpd3-utils::fn lpd3-utils::n) lpd3-utils::n #Y(lpd3-utils::map0-n nil nil (24 45 9 24 45 98 26 13 1 9 0 13 0 19 3 83 29) #1# #2# 3698) "(map0-n (fn n)). Return a list
  of the results of invoking fn on 0, 1, 
  2, ..., n." lpd3-utils::map1-n (defun lpd3-utils::map1-n) (#2# . 3829) (lpd3-utils::fn lpd3-utils::n) #Y(lpd3-utils::map1-n nil nil (24 45 9 24 45 98 26 13 1 9 1 13 0 19 3 83 29) #1# #2# 3829) "(map1-n (fn n)). Return a list of 
  the results of invoking fn on 1, 2, 3, ...,
  n." lpd3-utils::map-> (defun lpd3-utils::map->) (#2# . 3960) (lpd3-utils::fn lpd3-utils::start lpd3-utils::test lpd3-utils::succ) lpd3-utils::start lpd3-utils::succ #Y(lpd3-utils::map-> nil nil (24 45 9 24 45 111 24 45 25 24 45 112 26 13 2 77 46 72 46 90 38 24 13 5 13 0 20 1 23 12 10 1 3 51 1 13 2 13 0 20 1 23 12 53 0 13 3 13 0 20 1 23 39 -31 10 1 16 53 43 2 29) #1# #2# 3960) "Takes a function of one arg, fn, 
  a start value, and two more functions
  of one value, test and succ. Returns 
  a list. Invokes test on start. It test
  fails, returns nil. Else, invokes
  fn on start and puts the result in
  the return list. Then calls succ on
  start to find the next object. Continues
  accumulating results until test returns
  non-nil." lpd3-utils::do-tuples (defmacro lpd3-utils::do-tuples) (#2# . 4494) (lpd3-utils::parms lpd3-utils::source &body lpd3-utils::body) #:g536 #:g535 #:g537 si::dm-too-few-arguments lpd3-utils::parms lpd3-utils::source lpd3-utils::body gensym prog mapc lambda nthcdr #Y(nil nil nil (24 45 98 26 15 130 13 0 10 1 6 3 73 29) #1# #2# 4494) length 1- #Y(lpd3-utils::do-tuples nil nil (24 45 119 24 45 120 26 10 1 5 45 121 10 0 76 39 6 13 2 19 1 122 10 0 4 12 10 0 5 51 0 22 45 123 10 1 76 39 6 13 3 19 1 122 10 1 4 12 10 1 5 51 1 22 45 124 10 2 45 125 10 2 73 39 52 19 0 126 45 52 15 127 13 0 10 2 6 2 6 1 12 15 128 15 14 15 129 13 3 10 1 7 3 6 2 12 34 131 12 10 3 16 132 16 133 12 19 2 94 7 3 6 3 73 43 1 29) #1# #2# 4494) t "Given a list of symbols, a list, and a 
  body, repeatedly executes body. Let 
  n = length(parms). Then, on the first
  iteration the parms are bound to elts
  0 through n-1 of list. On the next, 
  parms are bound to elts 1-n of the list.
  Iteration continues until the last 
  elt has been bound to the last parm." lpd3-utils::%dt-args (defun lpd3-utils::%dt-args) (#2# . 5101) (lpd3-utils::len rest lpd3-utils::src) lpd3-utils::len lpd3-utils::m + >= nth - #Y(nil nil nil (24 45 98 26 13 1 13 0 19 2 143 45 21 13 0 13 5 19 2 144 39 18 15 145 13 0 13 5 19 2 146 12 10 3 6 3 73 38 13 15 145 10 0 16 133 12 10 4 6 3 73 43 1 29) #1# #2# 5101) #Y(nil nil nil (24 45 142 26 34 147 12 13 3 19 2 101 29) #1# #2# 5101) #Y(lpd3-utils::%dt-args nil nil (24 45 141 24 45 34 24 45 52 26 34 148 12 13 2 9 2 19 2 146 12 19 2 94 29) #1# #2# 5101) "Helper function for do-tuples*" lpd3-utils::do-tuples* (defmacro lpd3-utils::do-tuples*) (#2# . 5437) (lpd3-utils::parms lpd3-utils::source &body lpd3-utils::body) #:g539 #:g538 #:g540 "SRC" "REST" "BODFN" lpd3-utils::bodfn let when labels do cdr not lpd3-utils::args #Y(nil nil nil (24 45 168 26 13 4 10 0 7 2 73 29) #1# #2# 5437) mapcar (nil) append #Y(nil nil nil (24 45 98 26 15 145 10 0 16 133 12 10 3 6 3 73 29) #1# #2# 5437) #Y(lpd3-utils::do-tuples* nil nil (24 45 155 24 45 156 26 10 1 5 45 157 10 0 76 39 6 13 2 19 1 122 10 0 4 12 10 0 5 51 0 22 45 123 10 1 76 39 6 13 3 19 1 122 10 1 4 12 10 1 5 51 1 22 45 124 10 2 45 125 10 2 73 39 152 15 158 19 1 126 12 15 159 19 1 126 12 15 160 19 1 126 12 46 161 46 34 46 52 10 5 16 132 45 141 15 162 13 1 10 5 6 2 6 1 12 15 163 15 130 10 0 16 133 12 10 1 6 3 12 15 164 13 3 13 6 10 4 7 3 6 1 12 15 165 13 2 13 1 15 166 10 2 6 2 6 3 6 1 12 15 167 15 130 10 0 16 133 12 10 2 6 3 6 2 12 34 169 12 13 0 13 2 13 1 19 3 137 12 19 2 170 12 15 171 19 2 172 7 2 12 13 3 34 173 12 13 0 19 2 101 7 2 6 4 6 3 6 3 6 3 73 43 1 43 3 29) #1# #2# 5437) "Similar to do-tuples, but ``wraps around'',
  i.e., the last iteration binds the first
  parm to the last element of the list,
  and the rest from the front of the list." lpd3-utils::pull (defmacro lpd3-utils::pull) (#2# . 6373) (lpd3-utils::obj lpd3-utils::place &rest lpd3-utils::args) #:g542 #:g541 #:g543 lpd3-utils::place get-setf-expansion lpd3-utils::reader-form lpd3-utils::writer-form lpd3-utils::store-vars lpd3-utils::vals lpd3-utils::vars lpd3-utils::g let* delete #Y(lpd3-utils::pull nil nil (24 45 180 24 45 181 26 10 1 5 45 182 10 0 76 39 6 13 2 19 1 122 10 0 4 12 10 0 5 51 0 22 45 43 10 1 76 39 6 13 3 19 1 122 10 1 4 12 10 1 5 51 1 22 45 183 10 2 45 168 13 1 19 1 184 47 4 185 47 3 186 47 2 187 47 1 188 45 189 19 0 126 45 190 15 191 13 0 10 8 6 2 12 33 71 12 13 1 13 2 19 3 170 12 10 3 4 12 15 192 13 0 13 5 10 6 7 4 6 2 6 1 12 19 2 172 7 2 12 10 4 6 3 73 43 1 43 5 29) #1# #2# 6373) "Given an item, a place containing 
  a list, and optional args as for 
  DELETE, destructively remove one
  or more instances of the item from
  the list at place." lpd3-utils::pull-if (defmacro lpd3-utils::pull-if) (#2# . 6887) (lpd3-utils::test lpd3-utils::place &rest lpd3-utils::args) #:g545 #:g544 #:g546 delete-if #Y(lpd3-utils::pull-if nil nil (24 45 199 24 45 200 26 10 1 5 45 201 10 0 76 39 6 13 2 19 1 122 10 0 4 12 10 0 5 51 0 22 45 25 10 1 76 39 6 13 3 19 1 122 10 1 4 12 10 1 5 51 1 22 45 183 10 2 45 168 13 1 19 1 184 47 4 185 47 3 186 47 2 187 47 1 188 45 189 19 0 126 45 190 15 162 13 0 10 8 6 2 12 33 71 12 13 1 13 2 19 3 170 12 10 3 4 12 15 202 13 0 13 5 10 6 7 4 6 2 6 1 12 19 2 172 7 2 12 10 4 6 3 73 43 1 43 5 29) #1# #2# 6887) "Given a predicate test, a place 
  containing a list, and optional args
  as for DELETE-IF, destructively remove
  all items that pass the test from the
  list at place." lpd3-utils::popn (defmacro lpd3-utils::popn) (#2# . 7411) (lpd3-utils::n lpd3-utils::place) #:g548 #:g547 #:g549 si::dm-too-many-arguments "GN" "GLIST" lpd3-utils::glist lpd3-utils::gn prog1 subseq #Y(lpd3-utils::popn nil nil (24 45 209 24 45 210 26 10 1 5 45 211 10 0 76 39 6 13 2 19 1 122 10 0 4 12 10 0 5 51 0 22 45 98 10 1 76 39 6 13 3 19 1 122 10 1 4 12 10 1 5 51 1 22 45 183 10 2 39 6 13 4 19 1 212 13 0 19 1 184 47 4 185 47 3 186 47 2 187 47 1 188 45 189 15 213 19 1 126 12 15 214 19 1 126 12 46 215 46 216 15 191 13 0 10 8 6 2 12 33 71 12 13 2 13 3 19 3 170 12 13 1 10 6 6 2 12 10 4 4 12 15 130 13 0 10 1 6 3 6 2 6 2 12 19 2 172 7 2 12 15 217 15 218 13 1 9 0 10 0 6 4 12 10 5 6 3 6 3 73 43 2 43 5 29) #1# #2# 7411) "Given a non-negative integer n and 
  a place containing a list, destructively
  remove the first n items from the list
  at place, returning them in a list." lpd3-utils::propmacro (defmacro lpd3-utils::propmacro) (#2# . 7987) (lpd3-utils::propname) #:g551 #:g550 #:g552 lpd3-utils::propname defmacro (lpd3-utils::obj) (quote get) (quote quote) quote #Y(lpd3-utils::propmacro nil nil (24 45 225 24 45 226 26 10 1 5 45 227 10 0 76 39 6 13 2 19 1 122 10 0 4 12 10 0 5 51 0 22 45 228 10 1 39 6 13 3 19 1 212 15 229 13 0 15 230 15 71 15 231 15 43 15 71 15 232 15 233 10 0 6 2 6 3 6 4 6 4 73 29) #1# #2# 7987) "Given a plist keyname, create
  an access macro with the same name." lpd3-utils::propmacros (defmacro lpd3-utils::propmacros) (#2# . 8152) (&rest lpd3-utils::propnames) #:g554 #:g553 #:g555 lpd3-utils::propnames progn lpd3-utils::p #Y(nil nil nil (24 45 245 26 15 221 10 0 6 2 73 29) #1# #2# 8152) #Y(lpd3-utils::propmacros nil nil (24 45 240 24 45 241 26 10 1 5 45 242 10 0 45 243 15 244 1 246 12 13 0 19 2 170 7 2 73 29) #1# #2# 8152) "Given a series of plist keys, create
  access macros with the same names.")) #2# 0) #Y(si::bytecodes nil nil (15 2 15 3 15 4 15 5 19 4 6 15 2 14 7 77 15 8 19 4 6 15 2 1 12 12 19 2 13 15 2 15 14 15 15 19 3 16 1 2 73 29) #1# #2# 76) #Y(si::bytecodes nil nil (15 17 15 3 15 18 15 19 19 4 6 15 17 14 7 77 15 20 19 4 6 15 17 1 27 12 19 2 13 15 17 15 14 15 28 19 3 16 1 17 73 29) #1# #2# 420) #Y(si::bytecodes nil nil (15 29 15 3 15 30 15 31 19 4 6 15 29 14 7 77 15 32 19 4 6 15 29 1 37 12 19 2 13 15 29 15 14 15 38 19 3 16 1 29 73 29) #1# #2# 850) #Y(si::bytecodes nil nil (15 39 15 3 15 40 15 41 19 4 6 15 39 14 7 77 15 42 19 4 6 15 39 1 45 12 19 2 13 15 39 15 14 15 46 19 3 16 1 39 73 29) #1# #2# 1184) #Y(si::bytecodes nil nil (15 47 15 3 15 48 15 49 19 4 6 15 47 14 7 77 15 50 19 4 6 15 47 1 54 12 19 2 13 15 47 15 14 15 55 19 3 16 1 47 73 29) #1# #2# 1512) #Y(si::bytecodes nil nil (15 56 15 3 15 57 15 58 19 4 6 15 56 14 7 77 15 59 19 4 6 15 56 1 65 12 19 2 13 15 56 15 14 15 66 19 3 16 1 56 73 29) #1# #2# 1899) #Y(si::bytecodes nil nil (15 67 15 3 15 68 15 69 19 4 6 15 67 14 7 77 15 70 19 4 6 15 67 1 74 12 19 2 13 15 67 15 14 15 75 19 3 16 1 67 73 29) #1# #2# 2403) #Y(si::bytecodes nil nil (15 76 15 3 15 77 15 78 19 4 6 15 76 14 7 77 15 79 19 4 6 15 76 1 81 12 19 2 13 15 76 15 14 15 82 19 3 16 1 76 73 29) #1# #2# 3026) #Y(si::bytecodes nil nil (15 83 15 3 15 84 15 85 19 4 6 15 83 14 7 77 15 86 19 4 6 15 83 1 92 12 19 2 13 15 83 15 14 15 93 19 3 16 1 83 73 29) #1# #2# 3462) #Y(si::bytecodes nil nil (15 94 15 3 15 95 15 96 19 4 6 15 94 14 7 77 15 97 19 4 6 15 94 1 99 12 19 2 13 15 94 15 14 15 100 19 3 16 1 94 73 29) #1# #2# 3698) #Y(si::bytecodes nil nil (15 101 15 3 15 102 15 103 19 4 6 15 101 14 7 77 15 104 19 4 6 15 101 1 105 12 19 2 13 15 101 15 14 15 106 19 3 16 1 101 73 29) #1# #2# 3829) #Y(si::bytecodes nil nil (15 107 15 3 15 108 15 109 19 4 6 15 107 14 7 77 15 110 19 4 6 15 107 1 113 12 19 2 13 15 107 15 14 15 114 19 3 16 1 107 73 29) #1# #2# 3960) #Y(si::bytecodes nil nil (15 115 15 3 15 116 15 117 19 4 6 15 115 14 7 77 15 118 19 4 6 15 115 34 134 12 14 135 9 3 19 4 13 15 115 15 14 15 136 19 3 16 1 115 73 29) #1# #2# 4494) #Y(si::bytecodes nil nil (15 137 15 3 15 138 15 139 19 4 6 15 137 14 7 77 15 140 19 4 6 15 137 34 149 12 19 2 13 15 137 15 14 15 150 19 3 16 1 137 73 29) #1# #2# 5101) #Y(si::bytecodes nil nil (15 151 15 3 15 152 15 153 19 4 6 15 151 14 7 77 15 154 19 4 6 15 151 34 174 12 14 135 9 3 19 4 13 15 151 15 14 15 175 19 3 16 1 151 73 29) #1# #2# 5437) #Y(si::bytecodes nil nil (15 176 15 3 15 177 15 178 19 4 6 15 176 14 7 77 15 179 19 4 6 15 176 1 193 12 14 135 9 3 19 4 13 15 176 15 14 15 194 19 3 16 1 176 73 29) #1# #2# 6373) #Y(si::bytecodes nil nil (15 195 15 3 15 196 15 197 19 4 6 15 195 14 7 77 15 198 19 4 6 15 195 1 203 12 14 135 9 3 19 4 13 15 195 15 14 15 204 19 3 16 1 195 73 29) #1# #2# 6887) #Y(si::bytecodes nil nil (15 205 15 3 15 206 15 207 19 4 6 15 205 14 7 77 15 208 19 4 6 15 205 1 219 12 14 135 9 3 19 4 13 15 205 15 14 15 220 19 3 16 1 205 73 29) #1# #2# 7411) #Y(si::bytecodes nil nil (15 221 15 3 15 222 15 223 19 4 6 15 221 14 7 77 15 224 19 4 6 15 221 1 234 12 14 135 9 2 19 4 13 15 221 15 14 15 235 19 3 16 1 221 73 29) #1# #2# 7987) #Y(si::bytecodes nil nil (15 236 15 3 15 237 15 238 19 4 6 15 236 14 7 77 15 239 19 4 6 15 236 1 247 12 14 135 9 1 19 4 13 15 236 15 14 15 248 19 3 16 1 236 73 29) #1# #2# 8152))
